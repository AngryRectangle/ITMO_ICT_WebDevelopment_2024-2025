<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Задание 4 - Мои лабы</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Мои лабы</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Welcome to Мои лабораторные работы</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Lab1</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../task1/" class="dropdown-item">Задание 1</a>
</li>
                                    
<li>
    <a href="../task2/" class="dropdown-item">Задание 2</a>
</li>
                                    
<li>
    <a href="../task3/" class="dropdown-item">Задание 3</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">Задание 4</a>
</li>
                                    
<li>
    <a href="../task5/" class="dropdown-item">Задание 5</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../task3/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../task5/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#4" class="nav-link">Задание 4</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#_1" class="nav-link">Требования</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#_2" class="nav-link">Ход работы</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#_3" class="nav-link">Листинг кода</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_4" class="nav-link">Сервер</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_5" class="nav-link">Клиент</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="4">Задание 4</h1>
<p>Реализовать двухпользовательский или многопользовательский чат.
Для максимального количества баллов реализуйте многопользовательский чат.</p>
<h1 id="_1">Требования</h1>
<ul>
<li>Обязательно использовать библиотеку socket.</li>
<li>Для многопользовательского чата необходимо использовать библиотеку threading.</li>
</ul>
<h1 id="_2">Ход работы</h1>
<p>В начале реализовал чат на http ядре которое делал для других тасок, но пришлось переделать на отдельное
решение поверх tcp сокетов. Сервер принимает подключения, слушает сокеты и отправляет через них сообщения
в отдельном треде сервера, а "бизнес логика" по получению сообщений и выбиранию кому их отправить находиться в основном
треде.</p>
<p>На клиенте самой сложной задачей оказалось сделать не то, что требовалось напрямую по заданию,
а так чтобы сообщения от других пользователей не мешали вводу сообщений от текущего пользователя,
из-за того что при отправке сообщений ввод пользователя разбивался на несколько строк пришлось писать
страшные конструкции для очистки консоли, сохранения ввода пользователя по буквам и тд.</p>
<h1 id="_3">Листинг кода</h1>
<h2 id="_4">Сервер</h2>
<pre><code class="language-csharp">using System.Collections.Concurrent;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.Unicode;

namespace Server;

class Program
{
    static async Task Main(string[] args)
    {
        var listenPort = 22102;
        var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        socket.Bind(new IPEndPoint(IPAddress.Any, listenPort));
        socket.Listen(10);

        var webServer = new WebServer(socket);
        var packets = new List&lt;WebServer.ReceivedPacket&gt;();

        while (true)
        {
            webServer.FlushPackets(packets);
            foreach (var packet in packets)
            {
                var sender = packet.Sender;
                var message = UTF32Encoding.UTF32.GetString(packet.Value);
                var fullMessageText = $&quot;{sender.Address}:{sender.Port} : {message}&quot;;
                Console.WriteLine(fullMessageText);

                var dataToSend = UTF32Encoding.UTF32.GetBytes(fullMessageText);
                webServer.SendPacket(ip =&gt; !Equals(ip, sender), dataToSend);
            }

            packets.Clear();
        }
    }

    private class WebServer
    {
        private readonly Socket _socket;
        private readonly ConcurrentDictionary&lt;EndPoint, Connection&gt; _connections = new();
        private readonly ConcurrentQueue&lt;ReceivedPacket&gt; _packets = new();

        private bool _isWaitingForConnection;

        public WebServer(Socket socket)
        {
            _socket = socket;
            var thread = new Thread(() =&gt;
            {
                while (true)
                {
                    PollConnections();
                    PoolSend();
                    PoolReceive();
                }
            });

            thread.Start();
        }

        private void PollConnections()
        {
            if (_isWaitingForConnection)
                return;

            _isWaitingForConnection = true;
            var socketAsyncEventArgs = new SocketAsyncEventArgs();
            socketAsyncEventArgs.Completed += OnAccept;
            var isAsync = _socket.AcceptAsync(socketAsyncEventArgs);
            if (!isAsync)
                OnAccept(null, socketAsyncEventArgs);
        }

        private void PoolSend()
        {
            foreach (var connection in _connections.Values)
            {
                try
                {
                    if (connection.IsSending)
                        connection.PollWrite();
                }
                catch (SocketException e)
                {
                    if (e.SocketErrorCode == SocketError.ConnectionReset)
                        RemoveDisconnectedClient(connection);
                    else
                        throw;
                }

                if (!connection.Client.Connected)
                    RemoveDisconnectedClient(connection);
            }
        }

        private void OnAccept(object? sender, SocketAsyncEventArgs e)
        {
            if (e.SocketError != SocketError.Success)
            {
                Console.WriteLine(e.SocketError);
                return;
            }

            if (e.AcceptSocket == null)
            {
                Console.WriteLine(&quot;Accept socket is null&quot;);
                return;
            }

            var connection = new Connection(e.AcceptSocket);
            connection.Client.ReceiveTimeout = 1;
            connection.Client.SendTimeout = 1;
            _connections.TryAdd(connection.Client.RemoteEndPoint, connection);
            _isWaitingForConnection = false;
        }

        public void FlushPackets(List&lt;ReceivedPacket&gt; packets)
        {
            while (_packets.TryDequeue(out var packet))
                packets.Add(packet);
        }

        private void PoolReceive()
        {
            foreach (var connection in _connections.Values)
            {
                try
                {
                    while (connection.PollRead(out var result))
                        _packets.Enqueue(new ReceivedPacket(connection.Client.RemoteEndPoint as IPEndPoint, result));
                }
                catch (SocketException e)
                {
                    if (e.SocketErrorCode == SocketError.ConnectionReset)
                        RemoveDisconnectedClient(connection);
                    else
                        throw;
                }
            }
        }

        private void RemoveDisconnectedClient(Connection connection)
        {
            Console.WriteLine($&quot;Client {connection.Client.RemoteEndPoint} disconnected&quot;);
            _connections.TryRemove(connection.Client.RemoteEndPoint, out _);
        }

        public void SendPacket(Predicate&lt;IPEndPoint&gt; receiverFilter, Span&lt;byte&gt; data)
        {
            foreach (var connection in _connections.Values)
            {
                try
                {
                    if (receiverFilter(connection.Client.RemoteEndPoint as IPEndPoint))
                        connection.Send(data);
                }
                catch (SocketException e)
                {
                    if (e.SocketErrorCode == SocketError.ConnectionReset)
                        RemoveDisconnectedClient(connection);
                    else
                        throw;
                }
            }
        }

        public class ReceivedPacket
        {
            public IPEndPoint Sender;
            public byte[] Value;

            public ReceivedPacket(IPEndPoint sender, byte[] value)
            {
                Sender = sender;
                Value = value;
            }
        }
    }

    private class Connection : IDisposable
    {
        private const int PacketHeaderSize = 2;

        public readonly Socket Client;
        public readonly byte[] ReceiveBuffer = new byte[1024 * 8];
        public readonly byte[] SendBuffer = new byte[1024 * 8];

        public bool IsSending =&gt; _sentBytes &lt; _bytesToSent;

        private int _sentBytes;
        private int _bytesToSent;
        private int _bytesReceived;
        private int _bytesToReceive;

        public Connection(Socket client)
        {
            Client = client;
        }

        public void Send(Span&lt;byte&gt; data)
        {
            while (PollWrite())
                Thread.Sleep(1);

            var size = (ushort)data.Length;
            SendBuffer[0] = (byte)(size &amp; 0xFF);
            SendBuffer[1] = (byte)((size &gt;&gt; 8) &amp; 0xFF);

            var sizeWithHeader = data.Length + PacketHeaderSize;
            if (sizeWithHeader &gt; SendBuffer.Length)
                throw new InvalidOperationException(&quot;Data is too big&quot;);

            data.CopyTo(SendBuffer.AsSpan(PacketHeaderSize));
            _bytesToSent = sizeWithHeader;
            _sentBytes = 0;
        }

        public bool PollWrite()
        {
            if (_sentBytes &gt;= _bytesToSent)
                return false;

            try
            {
                var sentBytes = Client.Send(SendBuffer, _sentBytes, _bytesToSent - _sentBytes, SocketFlags.None);
                _sentBytes += sentBytes;
                return true;
            }
            catch (SocketException e)
            {
                if (e.SocketErrorCode != SocketError.TimedOut)
                    throw;

                return false;
            }
        }

        public bool PollRead([MaybeNullWhen(false)] out byte[] result)
        {
            result = null;

            if (_bytesReceived &lt; PacketHeaderSize)
            {
                try
                {
                    _bytesReceived += Client.Receive(ReceiveBuffer, 0, PacketHeaderSize - _bytesReceived,
                        SocketFlags.None);
                }
                catch (SocketException e)
                {
                    if (e.SocketErrorCode != SocketError.TimedOut)
                        throw;

                    return false;
                }

                if (_bytesReceived &lt; PacketHeaderSize)
                    return false;

                var packetSize = ReceiveBuffer[0] | (ReceiveBuffer[1] &lt;&lt; 8);
                _bytesToReceive = packetSize + PacketHeaderSize;
            }

            try
            {
                _bytesReceived += Client.Receive(ReceiveBuffer, _bytesReceived, _bytesToReceive - _bytesReceived,
                    SocketFlags.None);
            }
            catch (SocketException e)
            {
                if (e.SocketErrorCode != SocketError.TimedOut)
                    throw;

                return false;
            }

            if (_bytesReceived != _bytesToReceive)
                return false;

            result = new byte[_bytesToReceive - PacketHeaderSize];
            Array.Copy(ReceiveBuffer, 2, result, 0, result.Length);
            _bytesReceived = 0;
            _bytesToReceive = 0;
            return true;
        }

        public void Dispose()
        {
            try
            {
                Client.Dispose();
            }
            catch (SocketException)
            {
            }
        }
    }
}
</code></pre>
<h2 id="_5">Клиент</h2>
<pre><code class="language-csharp">using System.Collections.Concurrent;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace Server;

class Program
{
    static async Task Main(string[] args)
    {
        var listenPort = 22102;
        var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        socket.ReceiveTimeout = 1;
        socket.SendTimeout = 1;
        socket.Connect(IPAddress.Parse(&quot;127.0.0.1&quot;), listenPort);

        var connection = new Connection(socket);
        var messages = new ConcurrentQueue&lt;string&gt;();
        var thread = new Thread(() =&gt; PollMessages(connection, messages));
        thread.Start();

        var userInputBuffer = new StringBuilder();
        while (true)
        {
            while (messages.TryDequeue(out var result))
            {
                // Всё это нужно чтобы инпут юзера всегда оставался снизу
                var currentCursorPosition = Console.GetCursorPosition();
                Console.SetCursorPosition(0, currentCursorPosition.Top);
                Console.Write(new string(' ', Console.BufferWidth));
                Console.SetCursorPosition(0, currentCursorPosition.Top);

                Console.WriteLine(result);

                if (userInputBuffer.Length &gt; 0)
                    Console.Write(userInputBuffer.ToString());
            }

            if (!Console.KeyAvailable)
                continue;

            var key = Console.ReadKey(true);
            if (key.Key == ConsoleKey.Enter)
            {
                var userInput = userInputBuffer.ToString();
                var dataRaw = Encoding.UTF32.GetBytes(userInput);
                connection.Send(dataRaw);

                userInputBuffer.Clear();
                Console.WriteLine();
            }
            else
            {
                userInputBuffer.Append(key.KeyChar);
                Console.Write(key.KeyChar);
            }
        }
    }

    private static void PollMessages(Connection connection, ConcurrentQueue&lt;string&gt; messages)
    {
        while (true)
        {
            while (connection.PollRead(out var data))
            {
                var message = UTF32Encoding.UTF32.GetString(data);
                messages.Enqueue(message);
            }

            while (connection.PollWrite())
                Thread.Sleep(1);
        }
    }

    private class Connection : IDisposable
    {
        private const int PacketHeaderSize = 2;

        public readonly Socket Client;
        public readonly byte[] ReceiveBuffer = new byte[1024 * 8];
        public readonly byte[] SendBuffer = new byte[1024 * 8];

        private int _sentBytes;
        private int _bytesToSent;
        private int _bytesReceived;
        private int _bytesToReceive;

        public Connection(Socket client)
        {
            Client = client;
        }

        public void Send(Span&lt;byte&gt; data)
        {
            while (PollWrite())
                Thread.Sleep(1);

            var size = (ushort)data.Length;
            SendBuffer[0] = (byte)(size &amp; 0xFF);
            SendBuffer[1] = (byte)((size &gt;&gt; 8) &amp; 0xFF);

            var sizeWithHeader = data.Length + PacketHeaderSize;
            if (sizeWithHeader &gt; SendBuffer.Length)
                throw new InvalidOperationException(&quot;Data is too big&quot;);

            data.CopyTo(SendBuffer.AsSpan(PacketHeaderSize));
            _bytesToSent = sizeWithHeader;
            _sentBytes = 0;
        }

        public bool PollWrite()
        {
            if (_sentBytes &gt;= _bytesToSent)
                return false;

            try
            {
                var sentBytes = Client.Send(SendBuffer, _sentBytes, _bytesToSent - _sentBytes, SocketFlags.None);
                _sentBytes += sentBytes;
                return true;
            }
            catch (SocketException e)
            {
                if (e.SocketErrorCode != SocketError.TimedOut)
                    throw;

                return false;
            }
        }

        public bool PollRead([MaybeNullWhen(false)] out byte[] result)
        {
            result = null;

            if (_bytesReceived &lt; PacketHeaderSize)
            {
                try
                {
                    _bytesReceived += Client.Receive(ReceiveBuffer, 0, PacketHeaderSize - _bytesReceived,
                        SocketFlags.None);
                }
                catch (SocketException e)
                {
                    if (e.SocketErrorCode != SocketError.TimedOut)
                        throw;

                    return false;
                }

                if (_bytesReceived &lt; PacketHeaderSize)
                    return false;

                var packetSize = ReceiveBuffer[0] | (ReceiveBuffer[1] &lt;&lt; 8);
                _bytesToReceive = packetSize + PacketHeaderSize;
            }

            try
            {
                _bytesReceived += Client.Receive(ReceiveBuffer, _bytesReceived, _bytesToReceive - _bytesReceived,
                    SocketFlags.None);
            }
            catch (SocketException e)
            {
                if (e.SocketErrorCode != SocketError.TimedOut)
                    throw;

                return false;
            }

            if (_bytesReceived != _bytesToReceive)
                return false;

            result = new byte[_bytesToReceive - PacketHeaderSize];
            Array.Copy(ReceiveBuffer, 2, result, 0, result.Length);
            _bytesReceived = 0;
            _bytesToReceive = 0;
            return true;
        }

        public void Dispose()
        {
            try
            {
                Client.Dispose();
            }
            catch (SocketException)
            {
            }
        }
    }
}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
